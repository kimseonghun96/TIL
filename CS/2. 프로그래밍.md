# 2. 프로그래밍

## 프로그래밍언어

- **C**
  
  - 새로 개발된 유닉스 운영 체제에서 사용하기 위해 개발한 프로그래밍 언어
  - 유닉스 시스템의 바탕 프로그램은 모두 C 로 작성
  - 수많은 운영 체제의 커널 또한 C로 작성

- **C++**
  
  - C 언어에 객체지향 프로그래밍을 지원
  - 초기에는 C++ 프로그램을 일단 C프로그램으로 변환하고 나서 C컴파일러로 컴파일
  - C언어에 대해 상위 호환성을 갖는 언어
  - C++언어의 표준 규격은 복잡

- **Java**
  
  - 객체 지향적 프로그래밍 언어
  - 처음에는 가전제품 내에 탐재해 동작하는 프로그램을 위해 개발
  - 웹 애플리케이션 개발과 모바일 기기용 소프트웨어 개발에도 널리 사용
  - 가장 큰 특징은 컴파일된 코드가 플랫폼 독립적

- **PHP**
  
  - 동적 웹 페이지를 만들기 위해 설계되었으며 이를 구현하기 위해 PHP로 작성된 코드
  - PHP는 명령 줄 인터페이스 방식의 자체 인터프리터를 제공
  - 범용 프로그래밍 언어로도 사용

- **Python**
  
  - 플랫폼 독립적이며 인터프리터식, 객체지향적, 동적 타이핑(dynamically typed)대화형 언어
  - 동적 타이핑(dynamic typing). (실행 시간에 자료형을 검사한다.)
  - 객체의 맴버에 무제한으로 접근(속성이나 전용의 메서드 훅을 만들어 제한할 수 는 있음.)
  - 모듈, 클래스, 객체와 같은 언어의 요소가 내부에서 접근

- **인공지능**
  
  - 파이썬
    - 넘파이(NumPy, 텐서연산), 판다스(Pandas, 데이터프레임)
    - 자연어 처리(NLP) - NLTK, 스페이시(SpaCy)
    - 머신러닝 - 사이킷-런(Scikit-learn)
    - 딥 러닝이 - 텐션플로우(TensorFlow), 파이토치(PyTorch), 체이너(Chainer), 아파치 MXNet(Apache MXNet), 테아노(Theano) 등 )
  - 자바 - 자연어 처리(CoreNLP), 텐서 연산(ND4J) 또는 GPU 가속 딥 러닝 스택(DJ4J)
  - C/C++ - CUDA, 텐서플로우 또는 카페(Caffe), 러스트(Rust)
  - 자바스크립트 - TensorFlow.js(구굴이 제작한 머신러닝 모델의 학습 및 실행이 가능한 WebGL 가속 라이브러리), 케라스(Keras)API
  - 루아(Lua) - 토치(Torch) 프레임워크와 함께 딥 러닝 개발에서 가장 인기 있는 언어였음
  - 줄리아(Julia)
    - 수치 연산에 초점을 둔 고성능 프로그래밍 언어
    - TensorFlow.jl, 모카(Mocha-카페의 영향을 크게 받음)와 같은 래퍼는 딥 러닝을 충실하게 지원
  - 텐서플로우용 스위프트(Swift) - 파이썬이 제공하는 사용의 용이함과 컴파일 언어의 속도 및 정적 형식 확인을 결합하는 것을 목표

- **데이터분석**
  
  - python 은 좀더 본격적인 범용 개발언어이고, R은 통계쪽으로 특화된 패키지많음
  - **R**
    - 통계 계산과 그래픽을 위한 프로그래밍 언어이자 소프트웨어 환경
    - 통계 소프트웨어 개발과 자료 분석에 널리 사용
    - 패키지 개발이 용이해 통계 소프트웨어 개발
    - 다양한 통계 기법과 수치 해석 기법을 지원
    - 그래픽 기능으로 수학 기호를 포함할 수 있는 출판물 수준의 그래프를 제공

- **인공지능**
  
  - 기계 학습
    - 기본적인 규칙만 주어진 상태에서 입력받은 정보를 활용해 스스로 학습하는 것
  - 인공 신경망
    - 인간의 뉴런 구조를 본떠 만든 기계 학습 모델
  - 딥 러닝
    - 입력과 출력 사이에 있는 인공 뉴런들을 여러개 층층히 쌓고 연결한 인공신경망 기법을 주로 다루는 연구
    - 즉, 단일 층이 아닌 실제 뇌처럼 여러 계층으로 되어있음
  - 인지 컴퓨팅
    - 기계학습을 이용하여 특정한 인지적 과제를 해결할 수 있는 프로그램 또는 솔루션
  - 뉴로모픽 컴퓨팅
    - 인공신경망을 하드웨어적으로 구현한 것

- **IoT(사물인터넷)**
  
  - 센서기술(SMART Sensor)
    
    → 스마트 센서는 기존의 센서가 발전하여 지능화된 센서(intelligent sensor)
  
  - 측정 대상 물의 물리, 화학적 정보를 감지하는 일반 센서기술에 나노기술 또는 MEMS기술을 접목하여 데이터 처리, 자동보정, 자가진단, 의사결정, 통신 등의 신호처리 기능을 내장
  
  - MEMS(Micro Electro Mechanical Systems)
    
    - 반도체 침에 내장된 센서, 밸브, 기어, 반사경, 그리고 구동기 등과 같은 아주 작은 기계장치와 컴퓨터를 결합하는 기술
    - 소형화, 지능화가 요구되는 미래 환경에 대응하는 위한 핵심기술
    - 사물인터넷 분야의 핵심 요소의 센서 및 구동 장치 등을 초소형화, 고성능화, 고집적화, 복합화를 가능하게 하는 시스템화 기술

- **블록체인**
  
  - 암호 화폐
    - 암호 화폐는 화폐를 조폐하는 중앙 은행 없이, 일정한 주기마다 블록(Block)을 찾아내고 보상을 받아가는 식으로 화폐가 생성됨
    - 블록은 해당 암호 화폐가 사용하는 해시함수로 이루어져 있음
  - 암호 화폐 주요 용도 : 지불 거래 + 스마트 계약(자율실행계약)
  - 암호의 사용: 디지털 서명(소유권을 입증할 목적으로 사용) / 암호화 해시 함수(거래 id 및 블록 id를 만들 때 사용)
  - 채굴(Mining): 사용자가 컴퓨터의 연산 능력을 이용해 일일이 맞는 함수를 대입하는 식으로 해시를 찾아가는 과정
  - 블록(Block)
    - 해당 블록이 발견되기 이전에 사용자들에게 전파되었던 모든 거래 내역이 기록되어 있음
    - 이는 P2P 방식으로 모든 사용자에게 똑같이 전송되므로, 거래 내역을 임의로 수정하거나 누락시킬 수 없음
    - Peer-to-peer 방식
  - **블록 체인(Blockchain)**
    - 블록은 발견되 날짜와 이전 블록에 대한 연결고리를 갖고 있음. 이러한 블록들의 집합을 “블록 체인”이라 함.
    - 블록 체인은 기존의 중앙 서버에 거래 기록을 보관하는 것과는 달리, 모든 사용자에게 거래기록을 보여주며 서로 비교해 위조를 막음
    - 거래 내역이 담긴 장부를 한 곳에 모아 저장하는 것이 아니라
      - 거래에 참여한 모든 이가 장부를 나눠 가져서,
      - 하나의 가상 원장(Virtual Ledger)을 만들고 관리하는 것으로
      - 분산원장기술(DLT : Distributed Ledger Technology) 이라고도 불림.
    - 투명성과 비가역성을 지원하는 분산된 데이터베이스
      - 투명성(Transparency) : 거래 내역은 검증 가능
      - 비가역성(Irreversibility) : 기록된 거래 내역은 변경 불가능
      - 분산된 DB(Distributed DB) : 중앙 서버가 불필요한 분산된 DB

## 기타주요기술

- **형상관리**
  - SW개발 및 유지보수 과정에서 발생하는 변경 사항들을 관리하기 위해 개발된 일련의 활동
  - 소프트웨어 변경의 원인을 알아내고 제어하며 적절히 변경되고 있는지 확인하여 해당 담당자에게 통보하는 작업
  - 형상 관리는 소프트웨어 개발의 전 단계에 적용되는 활동으로, 유지보수 단계에서 수행
  - 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 그 목적으로 함
  - 버전관리(Version Control), 리비전 관리(Revison Control), 소스관리(Source Control), 소스코드 관리(Source Code <anagement)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9f851bec-2b30-45b3-af22-e2fd94cd4f99/Untitled.png)

- 버전 관리 프로그램종류
  - 종류 : SVN, git, Mercurial, Bazaar 등
  - 주로 SVN과 git을 사용
- SVN과 git의 비교

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f8c59e33-f238-4102-9e72-ba185737eba6/Untitled.png)

- 빌드도구
  - 빌드도구란
    - 빠른 기간동안에 계속해서 늘어나는 라이브러리의 추가
    - 프로젝트를 진행하며 라이브러리의 버전을 동기화하기 어렵기 때문에 등장
    - ANT, MAVEN, GRADLE
  - 빌드도구(Apache ANT)
    - Ant는 Java 기반의 빌드 도구로 다른 빌드 도구보다 역사가 오래되었다. Ant는 개발자가 원하는 것을 개발할 수 있다는 유연성에 큰 장점이 있다.
    - ANT의 특징
      - 각 프로젝트에 대한 XML 기반 빌드 스크립트 개발
      - 형식적인 규칙이 없음: 결과물을 넣을 위치를 정확히 알려줘야 하며, 프로젝트에 특화된 Target과 Dependency를 이용해 모델링
      - 절차적 : 명확한 빌드 절차 정의가 필요
      - 생명주기를 갖지 않기 때문에 각각의 target에 대한 의존관계와 일련의 작업을 정의해 주어야 함
  - 빌드도구(Apache MAVEN)
    - Maven은 프로젝트에 필요한 모든 ‘Dependency(종석성)’를 리스트의 형태로 Maven에게 알려 관리 할 수 있도록 돕는 방식을 말함
    - Dependency를 관리하고, 표준화된 프로젝트(Standardized project)를 제공
    - XML, remote repository를 가져 올 수 있음 : 개발에 필요한 종속되는 ‘jar’, ‘class path’를 다운로드 할 필요 없이 선언만으로 사용 가능
    - 상속형 : 하위 XML이 필요 없는 속성도 모두 표기
  - 빌드도구 (Apache Gradle)
    - Gradle은 JVM 기반의 빌드 도구로 기존의 Ant와 Maven을 보완
    - JAVA 혹은 Groovy를 이용해 logic을 개발자의 의도에 따라 설계
    - 오픈소스기반의 build 자동화 시스템으로 Groovy 기반 DSL(Domain-Spectfic Language)로 작성
    - Build-by-convention을 바탕으로함: 스크립트 규모가 작고 읽기 쉬움
    - Nulti 프로젝트의 빌드를 지원하기 위해 설계됨
    - 설정 주입 방식(Configuration Injection)
    - 따라서 초기 프로젝트 설정에 드는 시간을 절약할 수 있으며 기존으 Maven이나 Ivy등과 같은 빌드 도구들과도 호완이 가능함

## 객체지향 개념

- **객체의 개념**
  - 소프트웨어 객체는 현실 셰게의 객체를 필드와 매서드로 모델링한 것
  - 소프트웨어 객체는 상태를 필드(Field)로 정의하고, 동작을 메서드(Method)로 정의.
  - 필드는 객체 내부에 선언된 변수를 의미하고, 메서드는 객체 내부에 정의된 동장
- **절차 지향 프로그래밍**
  - 일련의 동작을 순서에 맞추어 단계적으로 실행하도록 명령어를 나열
  - 데이터를 정의하는 방법보다는 명령어의 순서와 흐름에 중점
  - 수행할 작업을 예상할 수 있어 직관적인데, 규모가 작을 때는 프로그래밍과 이해하기가 용이
  - 소프트웨어는 계산 위주이므로 절차 지향 프로그래밍이 적합
- **객체 지향 프로그래밍**
  - 소프트웨어의 구모가 커지면서 동작과 분리되어 전 과정에서 서로 복잡하게 얽혀 있는 데이터를 사용했기 때문에 절차 지향 프로그래밍 방식의 한계
  - 절차 지향 프로그램은 추후 변경하거나 확장하기도 어려움
  - 현실 세계를 개체 단위로 프로그래밍하며, 객체는 필드(데이터)와 메서드(코드)를 하나로 묶어 표현
- OOP의 주요개념
  - 캡슐화(정보 은닉)
    - 관련된 필드와 메서드를 하나의 캡슐처럼 포장해 세부 내용을 외부에서 알 수 없도록 감추는 것
  - 상속
    - 자녀가 부모 재산을 상속받아 사용하듯이 상위 객체를 상속받은 하위 객체가 상위 객체의 메서드와 필드를 사용하는 것
  - 다형성
    - 대입되는 객체에 따라서 메서드를 다르게 동작하도록 구현하는 기술. 실행 도중 동일한 이름의 다양한 구현체 중에서 메서드를 선택 기능
- 객체
  - 객체란 우리가 살아가는 세계에 존재하거나 생각할 수 있는 것을 말함
  - 현실세계에 존재하는 개념들 중 소프트웨어 개발 대상이 되는 것들은 모두 객체라고 할 수 있다.
- 클래스
  - 동일한 특성을 가지는 객체들의 추상화
  - 클래스는 객체를 생성할 수 있는 구조와 정보를 가지는 틀이라고 정의

| 객체지향 개념 | 명사 개념 | 예                                                                |
| ------- | ----- | ---------------------------------------------------------------- |
| 클래스     | 일반 명사 | 자동차, 원, 도시                                                       |
| 객체      | 고유 명사 | 자동차 클래스의 객체: 자동차1, 자동차2 원 클래스의 객체: 원1, 원2 도시 클래스의 객체: 서울, 부산, 대전 |

## 자바의 주요개념

- **추상클래스 / 인터페이스**
  
  - 추상클래스의 정의
  
  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/37eefe9c-0812-4708-a859-95f25972ed64/Untitled.png)
  
  - 추상 메소드 정의
    - ‘반드시 하위 메소드에서 구현해야 한다’는 것을 명시
    - 키워드 abstract로 지정한 메서드
    - 추상 클래스와 하위 클래스 관계
    - 추상 클래스는 직접 객체 생성을 금지
    - 하위 클래스를 통해서 객체를 생성
    - 추상 메소드는 추상 클래스 안에서만 선언이 가능
  - 인터페이스 개념
    - 자바에서 제공하는 기능으로, 다중 상속과 유사
    - 구현 코드 없이 모든 메소드가 추상 메소드
    - 데이터는 final static으로 정의되어 메모리 동적 할당이 필요없고 변경되지 않는 데이터만 수용하는 특별한 형태의 클래스
  - 인터페이스 사용시 장점
    - 서로 관련성이 떨어지는 클래스를 특별한 상속 관계 업이 연결하여 사용
    - 하나 이상의 클래스를 통해서 구현해야 하는 메소드를 선언
    - 클래스 내용을 알지 못해도, 인터페이스를 통해 접근
  - 인터페이스와 추상 클래스 차이점
    - 구현 코드의 삽입 여부에 따라 달라짐
    - 인터페이스는 외부 메소드 이름을 명확하게 하는데 사용
    - 추상 클래스는 다형성을 위해 일부 메소드를 하위 클래스 구현에 위임하고, 직접적인 클래스로 부터의 객체 생성을 막는데 사용
  - 인터페이스와 추상 클래스의 공통점
    - 모두 추상 메소드를 가짐

- **쓰레드**
  
  - 멀티테스킹
    
    - 프로세스란 운영체제에서 실행중인 하나의 프로그램
    - 멀티 프로세스란 두 개 이상의 프로세스가 실행되는 것
    - 멀티 태스킹이랑 두 개 이상의 프로세스를 실행하여 일을 처리
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5dbf80ad-c11b-4132-961f-a5ee287e8790/Untitled.png)
  
  - 멀티쓰래드
    
    - 스레드란 프로세스 내에서 실행되는 세부 작업 단위
    - 멀티 스레드란 하나의 프로세스에서 여러 개의 스레드가 병행적으로 처리되는 것
  
  - 스래드의 생성 방법
    
    - Thread 클래스를 상속 받는 방법
    - Runnavle 인터페이스를 구현하는 방법
    - Thread 클래스 생성자
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb13e363-d199-4923-b348-afec67d66b67/Untitled.png)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/10d06e3d-0cae-4b28-8541-ca996277dcbc/Untitled.png)
  
  - ready 상태와 blocked 상태의 상호 전환 사유

| ready 상태 → blocked 상태     | blocked 상태 → ready 상태           |
| ------------------------- | ------------------------------- |
| 객체의 wait()메소드 호출          | 객체의 notify()/notifyAll() 메소드 호출 |
| sleep() 메소드 호출            | sleep() 상태가 종료되었을 경우            |
| I/O 동작 수행                 | I/O 동작 완료                       |
| 다른 스레드의 join() 메소드 호출     |                                 |
| suspend() 메소드 호출(권장되지 않음) | resume() 메소드 호출 (권장되지 않음)       |

- 쓰레드 스케줄러(thread scheduler)
  
  - 쓰레드의 상태를 관리함
  - 사용자 마음대로 제어할 수 없음
  - 스케줄러가 어떤 특별한 방식으로 작동할 것을 가정하고 프로그램을 만들면 절대 안 됨
  - 스레드는 우선 순위 이외에도 데몬 스레드인지 아닌지 판단하는 플래그 속성을 갖고 있음

- 데몬 스레드
  
  - 서비스 스레드라고도 하고 낮은 우선순위를 갖는 경우가 많음.
  - 대표적인 데몬 스레드는 가비지 컬렉터

- 쓰레드 관리
  
  - 지역 변수를 제외한 모든 데이터와 메소드 공유 가능
  - 공유 변수를 여러 스레드 사이에서 단 하나의 스레ㅐ드에게만 사용 권한을 주는 것이 안전

- 병행성(concurrency) 문제
  
  - 두 개 이상의 쓰레드가 어떤 객체에 있는 하나의 데이터에 접근하게 되는 경우
  - 서로 다른 두 스택에서 실행되는 메소드가 객체에 있는 동일한 객체에 대한 게터 또는 세터 메소드를 호출하게 되는 경우
  - 쓰레드는 자신이 잠시 중단된 적이 있다는 것을 기억할 수 가 없음

- 동기화
  
  - 임계영역이란 멀티 스레드에 의해 공유자원이 참조될 수 있는 코드의 범위
  - 멀티 스레드 프로그램에서 임계영역을 처리하는 경우 심각한 문제가 발생 - 해결방법이 동기화
  - 동기화를 처리하기 위해 모든 객체에 락(lock)을 포함

- 쓰레드에서의 동기화
  
  - 쓰레드에서 동기화(synchronization)란 다중 쓰레드 환경에서 한번에 하나의 쓰레드 만이 공유 데이터를 접근할 수 있도록 제어하는 것
  - 여러 쓰레드가 동시에 실행되는 다중 쓰레드에서 데이터를 공유하기 위해서는 어떤 쓰레드가 다른 쓰레드의 상태와 행동 등을 고려
  
  ## 디자인 패턴

- 디자인 패턴 개요
  
  - 디자인 패턴은 클래스 라이브러리가 아니다
    - 클래스 라이브러리: 많이 사용되는 클래스들을 미리 만들어서 모아둔 것
    - 예: 통신 관련 클래스 라이브러리, 수학 관련 클래스 라이브러리
  - 클래스 라이브러리 구현 시, 디자인 패턴이 적용된다.
    - 예: java.util.Calendar 클래스에의 getIntance() 메소드에서 Factory Method패턴(4장)이 사용된다.
    - 다이어그램을 단순히 보지 말고, 그 의미를 읽어내야 한다.
  - 모든 행동 양식에는 패턴이 존재한다
    - (예: 건축설계, 패션, 테니스 자동차 운전 등)
  - OOD에도 패턴이 존재함을 발견 : 23가지 패턴
    - GoF : Erich Gamma, Richard Helm, Ralph Hohnson, John Vissides
  - Design Pattern의 정의
    - S/W 설계시 반복적으로 나타나는 일련의 규칙을 정의한 것
  - 고급 설계자는 DP을 사용한다.
    - 개발자도 설계자의 의도를 잘 파악해야 한다.
  - **디자인 패턴의 예 : MVC 패턴**

- Design Patterns in Smaltalk MVC
  
  - MVC(Model-View-Controller) Pattern

- Smalltalk에서 User Interface를 만들기 위한 패턴
  
  - Model (data) : 화면에 출력될 자료 관리
  - View : 화면 출력 담당
  - Controller: 사용자와 view간의 상호작용을 담당

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b4c542b9-9cee-4728-bac5-3df406286237/Untitled.png)

- MVC는 view와 model을 분리하고 이들 간의 “suㅠscribe/ notify” 프로토콜을 이용하여 동작
- **디자인 패턴의 3가지 유형**
  - Creational Pattern
    - 객체를 생성하는데 관련된 패턴들
    - 객체가 생성되는 과정에 유연성을 높이고, 코드의 유지가 쉬워진다.
  - Structural Pattern
    - 프로그램의 구조에 관련된 패턴들
    - 프로그램내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는데 많이 활용될 수 있는 패턴들
  - Behavioral Pattern
    - 반복적으로 사용되는 객체들의 상호작용을 패턴화 해 놓은 것

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0bc56ade-36b5-4896-bedb-d10b4130bcb2/Untitled.png)

- **디자인 패턴의 종류**
  - Abstract Factory
    - 구체[적인 클래스를 미리 정하지 않고, 상호 관련 있는 객체들의 패밀리(faimily)를 생성하는 인터페이스를 제공한다.
  - Adapter
    - 기존 클래스의 인터페이스를 사용자가 원하는 다른 인터페이스로 변환함으로써, 서로 다른 인터페이스 때문에 상호연동을 못하는 클래스들을 연동될 수 있도록 해준다.
  - Bridge
    - 시스템의 클래스들을 구현부분과 추상부분으로 분리하여 설계함으로써 두 부분이 상호 독립적으로 바뀔 수 있도록 한다.
  - Builder
    - 복잡한 객체를 생성하는 부분과 객체 표현부분을 분리함으로써, 서로 다른 객체 표현 부분들을 생성하더라도 동일한 객체 생성부분을 이요할 수 있게 한다.
  - Chain of Responsibility
    - 서비스 제공자들을 체인형태로 달아둠으로써, 서비스 요청자와 서비스 제공자의 결합도(coupling)를 약화시키고, 복수개의 서비스 제공자를 들 수 있다.
  - Command
    - 소프트웨어 내에서 발생할 수 있는 명령을 객체화시킴으로써, 명령을 기록하거나 명령을 수행하기 전 상태로 소프트웨어 상태를 복구할 때 이용할 수 있다.
  - Factor Method
    - 생성되는 객체에 대한 결정을 서브클래스가 할 수 있도록 객체 생성인터페이스를 제공한다.
  - Flyweight
    - 수많은 작은 객체들에 대해서 효율적인 공유기능을 제공한다.
  - Iterator
    - 자료구조의 내부적 표현과 상관없이, 저장되어 있는 자료요소들을 순차적으로 접근할 수 있는 방법을 제공한다.
  - Mediator
    - 객체들의 상호 작용을 캡슐화하는 객체를 정의한다. 이를 통하여 객체들 간의 커플링을 줄일 수 있으며, 각 상호 작용을 독립적으로 변경할 수 있다.
  - Observer
    - 한 객체의 상태에 변화가 일어나면, 해당 객체의 상태에 관심 있는 모든 다른 객체들에게 자동으로 변화가 발생한 사실을 알려준다. 즉 객체들간의 일-대-다(one-to-many) 관계를 표현한다.
  - Prototype
    - 원형(prototypical) 객체를 복사하는 방식으로 객체를 생성한다. 이를 통하여 생성하는 객체의 종류를 동적으로 지정할 수 있다.
  - Proxy
    - 특정 객체에 대한 접근을 관리하기 위하여 해당 객체의 대리자(surrogate)를 만든다.
  - Singleton
    - 특정 클래스의 객체가 단 하나만 생성되도록 보장하며, 그 객체에 대한 전역 접근이 가능하도록 해준다.
  - State
    - 객체의 상태정보가 변함에 따라, 마치 객체의 클래스가 변하는 것처럼, 객체의 행동도 바뀌도록 해준다.
  - Strategy
    - 알고리즘을 객체화하여 여러 알고리즘을 동적으로 교체가능 하도록 만든다.
    - 알고리즘을 이용하는 클라이언트 코드와는 상관없이 알고리즘을 다양하게 바꿀 수 있다.
  - Template Method
    - 연산에 있어서 전체 알고리즘의 윤곽만 기술한 다음, 알고리즘의 특정 부분의 구현을 서브클래스 구현
    - 전체 알고리즘의 구조를 변화시키지 않으면서 서브클래스가 알고리즘의 특정부분을 쉽게 변경
  - Visitor
    - 자료구조 내에 있는 객체 요소들에게 특정 연산을 수행하고자 원할 때 이용
    - Visitor는 연산 수행의 대상이 되는 객체들의 클래스를 바꾸지 않고도 새로운 연산을 추가

## 웹 서버의 종류

- Apache web server - the HTTP web server
  
  - Apache Software Foundation에서 개발한 세계적으로 가장 유명하고 널리 쓰이는 무료 웹 서버. Apache 웹 서버는 오픈 소스 소프트웨어로써 Linux, Unix, Windows, FreeBSD, Mac OS X 등과 같은 거의 모든 운영 체제에서 설치 및 사용이 가능하다.

- Apache Tomcat
  
  - Apache Tomcat은 servlet과 JSP script을 지원하도록 개발
  - Apache Tomcat만으로도 독립적으로 서버로 사용할 수 있지만, 보통 Apache HTTP 웹 서버나 다른 웹 서버와 함께 사용
  - Apache Tomcat은 무료 오픈 소스이며 Linux, Unix, Windows, Mac OS X, Free BSD 등과 같은 다양한 운영 체제에서 사용이 가능

- Microsoft사의 Internet Information Services (IIS) Windows Server
  
  - IIS Windows 웹 서버는 기존 서버에 비해 높은 수준의 성능과 보안을 제공한다.
  - Microsoft사로부터 양질의 지원을 받음

- Nginx web server
  
  - IMAP/POP3 프록시 서버를 포함하는 무료 오픈 소스 웹 서버. 전세계 도메인의 약 7.5%를 호스팅
  - Nginx는 리퀘스트를 스레드로 처리하지 않고, 확장성이 있는 이벤트 기반 설계로 적은 양의 에측 가능한 양의 메모리를 사용

- Lighttpd
  
  - lighttpd는 FreeBSD 운영 체제와 함께 제공되는 무료 웹 서버
  - 오픈 소스 웹서버로 빠르고 보안성이 있으며 비교적 적은 CPU 파워를 사용
  - Windows, Mac OS X, Linux and Solaris 운영 체제에서 사용이 가능

- Jigsaw
  
  - Jigsaw는 World Wide Web 컨소시엄(W3C)에서 개발
  - 무료 오픈 소스로써 Linux, Unix, Windows, Mac OS X Free BSD 등과 같은 플랫폼에서 사용 가능
  - Jigsaw는 Java로 쓰여졌으며 CGI 스크립트와 PHP 프로그램도 실행

- Klone
  
  - Klone은 KoanLogic Srl사에서 개발되었으며, 정적/동적인 웹사이트를 위한 웹 서버와 SDK를 제공
  - 임베디드 시스템과 어플리케이션을 위한 웹 어플리케이션 개발 프레임워크
  - HTTP/S 서버나 PHP, Perl, ASP를 사용하지 않아도 된다.

- Abyss web server
  
  - Abyss 컴팩트 웹 서버는 Windows, MAc OS X, LinuX, FreeBSD에서 사용이 가능
  - 개인 사용을 위한 에디션(X1)dms 100% 무료이며, 프로페셔널 Abyss 웹 서버(X2)는 $60
  - HTTP/1.1, 보안성, CGI/FastCGI, 사용자 정의 오류 페이지, 비밀번호 보호, 안티 해킹 시스템, 다국어 원격 웹 관리 인터페이스 등을 제공

- Oracle Web Tier
  
  - 오라클은 http 트래픽을 처리하는 리버스 프록시와 캐싱 솔루션을 포함하는 두가지 웹 서버 옵션을 제공한다.
  - iPlanet 웹 서버는 64 비트 멀티 프로세서를 위한 멀티스레드 설계, 보안성, 성능을 제공한다.

- Web Accessibility Initiative (WAI)에서의 정의
  
  1. 웹접근성은 장애를 지닌 사람이 웹을 이용할 수 있는 것을 의미
  2. 장애를 가진 사람들이 웹 콘텐츠를 인지하고, 편리하게 사용할 수 있으며, 그 내용이 이해하기 쉬어햐 하며, 견고성을 지녀야 웹 접근성이 있다고 보는 관점.

- Web Content Accessibility Guidelines (WCAG 2.0)의 웹접근성 지침의 목적
  
  1. WCAG 1.0기준과 달리 장애인의 실제적인 사용성에 초점을 맞춘 것이 가장 큰 특징.
  2. 인터넷 기술의 발전 속도에 맞는 신기술 수용 부분까지 고려해서 제정
  3. 사용성이란 접근성이 확대된 개념으로 단순히 장애인이 웹에 접근하는 수준에서 한 걸음 더 나아가 인터넷을 직접 활용할 수 있도록 하는데 초점을 맞춤.

- WCAG 2.0 가이드 라인
  
  1. 인지성 - 정보와 사용자 인터페이스 요소는 그들이 인지할 수 있도록 사용자에게 표시될 수 있어야 한다.
     - 1.1. 모든 텍스트가 아닌 콘텐츠에 대체 텍스트를 사람들이 원하는 인쇄, 점자, 음성, 기호 또는 간단언어들과 같은 형태로 제공해야 한다.
     - 1.2. 시간에 기본한 미디어에 대한 대안을 제공해야 한다.
     - 1.3. 정보와 구조 손실 없이 콘텐츠를 다른 방식(예를들면 더욱 간단한 형태)들로 표현될 수 있어야 한다.
     - 1.4. 사용자들이 보다 쉽게 보고 들을 수 있는 전경에서 배경을 분리한 콘텐츠를 만들어야 한다.
  2. 운용성 - 사용자 인터페이스 요소와 탐색은 운용 가능해야 한다.
     - 2.1. 키보드로 모든 기능을 사용할 수 있도록 해야 한다.
     - 2.2. 읽기 및 콘텐츠를 사용하는 사용자에게 충분한 시간을 제공해야 한다.
     - 2.3. 알려진 방법으로 발작을 일으킬 수 있는 콘텐츠를 디자인하지 않아야 한다.
     - 2.4. 사용자가 탐색하고, 콘텐츠를 찾고 그들이 어디에 위치해 있는지를 알 수 있도록 도와주는 방법을 제공 해야 한다.
  3. 이해성 - 정보와 사용자 인터페이스 운용은 이해할 수 있어야 한다.
     - 3.1. 텍스트 콘텐츠를 판독하고 이해할 수 있도록 만들어야 한다.
     - 3.2. 웹페이지의 운용을 예측 가능한 방법으로 제작해야 한다.
     - 3.3. 사용자의 실수를 방지하고 수정할 수 있도록 도와야 한다.
  4. 내구성 - 콘텐츠를 보조기술을 포함한 넓고 다양한 사용자 에이전트에 의존되어 해석될 수 있도록 충분한 내구성을 가져야 한다.
     - 4.1. 보조기술을 포함한 연재 및 미래의 사용자 에이전트 호환성을 극대화해야 한다.

- 한국형 웹 콘텐츠 접근성 지침 2.0
  
  - 1. 웹 접근성을 고려한 콘텐츠 제작 방법
    
    2. 원칙, 지침, 검사 항목의 3단계로 구성
    
    3. 본 지침을 준수할 경우, 비장애인, 노인 등이 장애인, 젊은이 등과 동등하게 웹사이트에서 제공하는 콘텐츠를 인식하고, 이를 운영하고 이해할 수 있게 되는 것

- 한국형 웹 콤텐츠 접근성 2.0개요 (KWCAG 2.0)
  
  1. 인식의 용의성 - 모든 콘텐츠는 사용자가 인식할 수 있어야 한다.
     - 대체 텍스트 / 멀티미디어 대체 수단 / 명료성
  2. 운용의 용의성 - 사용자 인터페이스 구성요소는 조작 가능하고 내비게이션할 수 있어야 한다.
     - 키보드 접근성 / 충분한 시간 제공/ 광과민성 발작 예방/ 쉬운 내비게이션
  3. 콘텐츠는 이해할 수 있어야 한다.
     - 가독성 / 예측가능성 / 콘텐츠의 논리성/ 입력 도움
  4. 견고성 - 웹 콘텐츠는 미래의 기술로도 접근할 수 있도록 견고하게 만들어야 한다.
     - 문법준수/ 웹 애플리케이션 접근성
