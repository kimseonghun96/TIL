# 1. 소프트웨어 공학

# 소프트웨어

### 소프트웨어의 목표

- 개발 과정에서의 생산성 향상
- 고품질의 소프트웨어 생산 → 사용자 만족

### 소프트웨어의 문제점

- 소프트웨어 개발의 느린 발전 속도

- 새로운 소프트웨어에 대한 사용자 요구의 증가

- S/W 개발에도 관리가 필요
  
  → 비용관리 / 일정 관리 / 개발자 관리
  
  → PMBOK를 활용한 적극적인 프로젝트 관리 필요

- 개발과정이 복잡해지고 있음

- 참여 인력이 많아지고 있음

- 개발기간이 길어지고 있음

## 소프트웨어 개발 생명주기

- 소프트웨어 개발 생명주기(SDLC Software Development Life Cycle)
- 계획 단계에서 유지보수 단계에 이르기까지 일어나는 일련의 과정

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ecef1b8a-11b3-45c1-8f24-8797ad095508/Untitled.png)

### 소프트 웨어 프로세스 정의

- 소프트웨어 개발에서의 프로세스
  - 직업(task)순서의 집합 + 제약 조건(일정, 예산, 자원)을 포함하는 일련의 활동( activity)
  - 작업(task) : SW를 개발할 때 일을 수행하는 작은 단위
- (좁은 의미)소프트웨어 개발 프로세스
  - SW제품을 개발할 때 필요한 절차, 과정, 구조
  - 사용자의 요구사항을 SW시스템으로 구현하기 위한 일련을 활동
- (넓은 의미) 소프트웨어 개발 프로세스
  - 절차, 구조, 방법, 도구, 참여자까지 모두 포함
  - SW개발 목적을 이루는데 필요한 통합적 수단

### 소프트웨어 개발 프로세스

- 1단계 : 계획 -2단계: 요구분석 -3단계 : 설계 -4단계: 구현 - 5단계: 테스트 -6단계: 유지보수

## 소프트 웨어 프로세스 모델

### 소프트웨어 프로세스 모델의 정의

- 소프트웨어 개발 생명주기(SDLC Software Development Life Cycle)
- SW를 어떻게 개발할 것인가에 대한 전체적인 흐름을 체계화한 개념
- 개발 계획 수립부터 최종 폐기 때까지의 전 과정을 다룸
- 순차적인 단계로 이루어짐
- 소프트웨어 프로세스 모델의 목적
- 공장에서 제품을 생산하듯이 소프트웨어 개발의 전 과정을 하나의 프로세스로 정의
- 주어진 예산과 자원으로 개발하고 관리하는 방법을 구체적을 정의
- 고품질의 소프트웨어 제품 생산을 목적으로

### 소프트웨어 프로세스 모델의 역할

- 프로젝트에 대한 전체적인 기본 골격을 세워줌

- 일정 계획을 수립할 수 있음

- 개발 비용 산정뿐 아니라 여러 자원을 산정하고 분배할 수 있음

- 참여자 간에 의사소통의 기준을 정할 수 있음

- 용어의 표준화를 가능케 할 수 있음

- 개발 진행 상황을 명확히 파악할 수 있음

- 각 단계별로 생성되는 문서를 포함한 산출물을 활용하여 검토할 수 있게 해줌

- 선형 순차적 모델
  
  - Linear sequential 모델, waterfall 모델, Clssic Life cycle

- **폭포수 모델**의 장점
  
  - 관리의 용이
  - 체계적인 문서화
  - 요구사항의 변화가 적은 프로젝트에 적합

- 폭포수 모델의 단점
  
  - 각 단계는 앞 단계가 완료되어야 수행할 수 있다.
  - 각 단계의 결과물이 완벽한 수준으로 작성되어야 다음 단계에 오류를 넘겨주지 않는다.
  - 사용자가 중간에 가시적인 결과를 볼 수 없어 답답해할 수 있다.
  
  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6dbc2751-6395-4b9f-9a2f-c215c52a58d1/Untitled.png)

- **V 모델**
  
  - 소프트웨어 개발 프로세스로 폭포수 모델의 확장된 형태
  - 이 프로세스는 오른쪽 그림과 같이 코딩 단계에 위쪽으로 꺾여서 알파벳 V자 모양으로 진행
  - V 모델은 개발 생명주기의 각 단계와 그에 상응하는 소프트웨어 시험 각 단계의 관계를 보여줌
  - V 모델은 소포트웨어 개발의 각 단계마다 상세한 문서화를 통해 작업을 진행하는 방법을 사용
  - 테스트 설계와 같은 테스트 활동을 코딩 이후가 아닌 프로젝트 시작 시에 함께 시작함
  - 전체적으로 많은 양의 프로젝트 비용과 시간을 감소시킨다.
  
  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1bca7b53-5c55-4b8f-aba0-199a522ec9c2/Untitled.png)

- **프로토타입 모델**

- 프로토타입 모델의 개발 생명주기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c31b688-f0c0-4810-8776-1213c70b8457/Untitled.png)

- 프로토타입 모델의 장점
  
  - 반복된 요구사항 정의를 통해 사용자 요구가 충분히 반영된 요구 분석 명세서 작성
  - 초기 프로토타입 사용을 통한 새로운 요구사항 발견
  - 프로토타입 사용을 통한 완성품의 예층 가능

- 단점
  
  - 반복적 개발을 통한 투입 인력 및 비용 산정의 어려움
  - 프로토타이핑 과정에 대한 통제 및 관리의 어려움
  - 불명확한 개발 범위로 인한 개발 종료 및 목표의 불확실성

- **나선형 모델**
  
  - 진화적 프로토타입 모델 + 위험 분석
  - 위험분석 단계의 위험 요소의 예
    - 빈번히 변경되는 요구사항
    - 팀원들의 경험 부족
    - 결속력이 떨어지는 팀워크
    - 프로젝트 관리 부족
  - 나선형 모델의 개발절차
    - 계획 및 요구 분석 단계 > 위험 분석 단계 > 개발 단계 > 사용자 평가 단계
  - 장점
    - 사전 위험 분석을 통한 돌출 위험 요소 감소 → 프로젝트 중단 확률 감소
    - 사용자 평가에 의한 개발 방식 → 요구가 충분히 반영된 제품 → 사용자의 불만 감소
  - 단점
    - 반복적 개발에 의한 프로젝트 기간 연장의 가능성
    - 반복 회수의 증가에 따른 프로젝트 관리의 어려움
    - 위험 관리의 중요 → 위험 전문가 필요에 따른 부담

- **통합 프로세스 모델(UP) 모델**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9fad89c8-9ecc-4b4f-a687-cf27f2b03a60/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/30fe6435-283a-42bb-bd37-c93338d2927e/Untitled.png)

- **애자일 프로세스 모델**
  - 애자일(agile)
  - ‘날렵한’, ‘민첩한’
  - 고객의 요구에 민첩하게 대응하고 그때그때 주어지는 문제를 풀어나가는 방법론
- 애자일 기본 가치(애자일 선언문)
  - 프로세스 도구 중심이 아닌, 개개인과의 상호 소통 중시
  - 문서 중심이 아닌, 실행 가능한 소프트웨어 중시
  - 계약과 협상 중심이 아닌, 고객과의 협력 중시
  - 계획 중심이 아닌, 변화에 대한 민첩한 대응 중시
  - 애자일 개발 방법
    - 반복적인 개발을 통한 잦은 출시를 목표로 함
  - 프로토타입 개발 → 사용자 확인 → 일부 기능 사용

## 소프트웨어 일정 계획(1)

### SW 개발 프로젝트에서의 일정 계획

- 일정 계획
  - 작업 순서 결정, 소작업의 개발 기간, 순서, 필요한 자원 등의 일정 게획

### 작업 분할 구조도(WBS: Work Breakdown Structure)

- 프로젝트 목표를 달성하기 위해 필요한 활동과 업무를 세분화하는 작업
- 프로젝트 구성 요소들을 계층 구조로 분류
- 프로젝트의 전체 범위 정의
- 프로젝트 작업을 세분화

### PERT/CPM

- WBS의 작업 순서, 소요 기간 등을 네트워크 형태의 그래프로 표현한 후 어떤 작업이 중요한지, 또 일정에 여우가 있는 작업은 어떤 것인지 찾아내 중점 관리를 해야 하는 작업을 명확히 하는데 사용
- 프로젝트를 완료할 수 있는 최소 기간은 얼마인지, 완료 기간을 맞추기 위해서는 각 작업을 언제 시작하고 완료해야 하는지, 지연되지 않으려면 어떤 작업에 특히 주의를 기울여야 하는지 또 전체 프로젝트 완료 기간을 단축하기 위해서는 어떤 작업들을 단축하는 것이 가장 경제적인지 등의 관리자의 고민에 답을 주기 위해 필요한 도구

### 간트 차트(Gantt chart)

- 프로젝트 일정관리를 위한(bar) 현태의 도구

## 소프트 웨어 품질(1)

- **신뢰성**
  
  1. 신 뢰 : 소프트웨어를 믿고 사용할 수 있는 것(고장없이 사용)
  2. 신뢰도 : 장애 없이 동작하는 시간의 비율

- 신뢰도 측정 : 고장 간 평균 시간(MTBF)과 이용 가능성(가용성)을 척도로 사용

- MTBF = MTTF + MTTR
  
  - MTBF( 고장 간 평균 시간, Mean Time Between Failure) : 고장에서 다음 고장까지의 평균 시간
  - MTTF(평균 실패 시간, Mean Time To Failure) : 수리한 후 다음 고장까지의 평균 시간
  - MTTR(평균 수리 시간, Mean Time To Repair) : 고장 발생 시점에서 수리 시까지의 평균 시간

- 이용 가능성 availability=MTTF/(MTTF + MTTR) X 100% → 이용 가능성(가용성) : 주어진 시점에서 프로그램이 요구에 따라 작동되고 있을 가능성

- 성능 : 사용자가 시스템에 어떤 요구를 했을 때 해당 기능을 정상적으로 수행하는 것은 물론, 사용자가 원하는 조건(응답 시간, 데이터의 처리량 등) 을 만족시키는 것

- 보안성 : 인증을 받지 않은 사람이 시스템에 접근하는 것을 처음부터 막아 시스템과 데이터를 보호

- 안정성 : 작동하는 모든 시스템이 소프트웨어 오류로 인해 인명 피해가 발생하지 않도록

- 사용성 : 소프트웨어를 사용할 때 혼란스러워하거나 사용하는 순간에 고민하지 않게 하는 편의성

## 소프트웨어 아키텍쳐

- **아키텍처의 정의**
  
  - 구성 요소
  - 구성 요소들 사이의 관계
  - 구성 요소들이 외부에 드러내는 속성
  - 구성 요소들과 주변 환경 사이의 관계
  - 구성 요소들이 제공하는 인터페이스
  - 구성 요소들의 협력 및 조립 방법

- **소프트웨어 아키택처**
  
  - 소프트웨어에 대한 전체적인 구조
  - 소프트웨어를 이루고 있는 여러 구성 요소(서브시스템, 컴포넌트)
  - 구성 요소들의 인터페이스 간의 상호작용 정의
  - 시스템 설계와 개발 시 적용되는 원칙과 지침

- 소프트웨어 아키텍처 품질속성
  
  - 시스템 품질 속성
    
    - 가용성(availability) / 변경 용이성(modifiability) / 성능(performance) / 보안성(security) / 사용성(usability) / 테스트 용이성(testabilty)
  
  - 비즈니스 품질 속성
    
    - 시장 적시성(time to market) / 비용과 이익 (const and benefit) /
      
      예상 시스템 수명 (predicted lifetime of the system) / 목표 시장(targeted market) /
      
      신규 발매 일정 또는 공개 일정(rollout schedule) /
      
      기존 시스템과의 통합 (integration with legacy system)
  
  - 아키텍처 품질 속성
    
    - 개념적 무결성 (conceptual integrity) : 일관성
    - 정확성과 완전성 (correctness and completeness) : 사용자가 요규하는 기능(요구명세서)을 충족시키는 정도
    - 개발 용이성 (구축 가능성, buildability) : 정해진 기간 내에 완성하고, 개발 과정 중에 쉽게 변경가능

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5f2e17bf-2d72-46e3-af2b-1fc7e27dc190/Untitled.png)

- **데이터 중심형 모델**
  
  - respository model
  - 주요 데이터가 repository에서 중앙 관리
  - repository와 여기에 접근하는 서브시스템으로 구성
  - 데이터가 한군데에 모여 있기 때문에 데이터를 모순되지 않고 일관성 있게 관리 가능
  - 새로운 서브시스템의 추가 용이
  - repository의 병목 현상 발생 가능
  - 서브시스템과 repository 사이의 강한 결합
  - epository 변경 시 서브시스템에 영향을 줌
  
  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/08a270d5-472b-4472-883c-4731e89105e5/Untitled.png)

- **Client-server 모델**
  
  - 네트워크를 이용하는 분산 시스템 형태
  - 데이터와 처리 기능을 클라이언트와 서버에 분할하여 사용
  - 분산 아키텍처에 유용
  - 서버: 클라이언트(서브시스템)에 서비스 제공
  - 클라이언트: 서버가 제공하는 서비스를 요청(호출)하는 서브시스템
  
  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2996599-9e5a-4402-886b-94d4df52c281/Untitled.png)

- Model/View/Controller 모델(MVC)
  
  - 중앙 데이터 구조
  - 같은 모델의 서브시스템에 대하여 여러 뷰 서브시스템을 필요로 하는 시스템에 적합
  - 장점
    - 데이터를 화면에 표현(뷰)하는 디자인과 로직(모델)을 분리함으로써 느슨한 결합 가능
    - 구조 변경 요청 시 수정 용이
  - 단점
    - 기본 기능 설계로 인한 클래스 수의 증가로 복잡도 증가
    - 속도가 중요한 프로젝트에 부적합
  
  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/78fd46b3-8b00-4593-b10a-2154b93220f9/Untitled.png)

## 디자인 패턴

- 디자인 패턴
  
  - 자주 사용하는 설계 형태를 정형화해서 이를 유형별로 설게 템플릿을 만들어둔 것
  - 많은 개발자들이 경험상 체득한 설계 지식을 검증하고 이를 추상화하여 일반화한 템플릿

- 장점
  
  - 개발자(설계자) 간의 원활한 의사소통
  - 소프트웨어 구조 파악 용이
  - 재사용을 통한 개발 시간 단축
  - 설계 변경 요청에 대한 유연한 대처

- 단점
  
  - 객체지향 설계/구현 위주
  - 초기 투자 비용 부담

- **Gof 디자인 패턴**
  
  - A. Creational Pattern
    - 객체를 생성하는데 관련된 패턴들
    - 객체가 생성되는 과정의 유연성을 높이고 코드의 유지를 쉽게 함
  - B. Structural Pattern
    - 프로그램 구조에 관련된 패턴들
    - 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는데 활용할 수 있는 패턴들
  - C. Behavioral Pattern
    - 반복적으로 사용되는 객체들의 상호작용을 패턴화 해놓은 것들

## 방법론

- 객체지향 방법object-oriented approach
  - 프로세스 지향 방법과 데이터 지향 방법의 문제점을 해결하기 위해 고안
  - 기능이나 데이터 대신 객체가 중심이 되어 개발
  - 데이터(속성)를 가장 먼저 찾고 그 데이터를 조작하는 메서드(함수)를 찾아 그 둘을 객체라는 이름으로 묶어 그 객체를 중심으로 모듈을 구성
  - 객체지향 방법의 특징
    - 실세계를 사람이 생각하는 방식으로 표현한다.
    - 임의로 데이터에 접근할 수 없다.
    - 시스템은 객체들의 모임이다
    - 요구 사항 변경에 유연하게 대처할 수 있다.
    - 확장성과 재사용성이 높아진다
    - 추상화를 통해 생산성과 품질이 높아진다
- **소프트웨어 품질 정의**
  - ‘사용자의 요구와 부합되는 정도’
  - US DoD: 개발된 소프트웨어가 사용자의 요구 사항을 만족할 수 있는 능력
  - IEEE
    - 소프트웨어가 필요한 속성을 보유하고 있는 정도
    - 사용자의 기대 수준을 만족할 수 있는 정도를 결정하는 소프트웨어의 특성
  - 개발자 관점에서의 좋은 소프트웨어
  - 결함 없는 프로그램
  - 요구 분석 명세서대로 만든 소프트웨어

## 소프트웨어 품질

- **품질목표**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6edd327f-42c3-4207-ae44-f1807580348d/Untitled.png)

- 프로젝트PMI : 유일한 제품이나 서비스를 만들기 위해 일정한 기간을 정해놓고 수행하는 작업
- 프로젝트 특징
  - 한시성: 일의 시작과 끝이 명확히 정해져 있다.
  - 유일성: 기간이 종료되어 만들어 내는 인도물은 유일하다.
  - 참여자의 일시성: 참여 인력은 프로젝트 시작과 동시에 참여하고, 종료되면 해체된다.
  - 한정성: 프로젝트가 종료되면 사용된 자원은 원래의 위치로 돌아가던가 없앤다.
- PMBOK의 5가지 프로세스 그룹
  1. 시작 initating 그룹 - 핵심 프로세스 : 범위 관리 착수 및 프로젝트 또는 프로젝트를 구성하는 단계 정의 및 승의
  2. 기획 plannig 그룹 - 프로젝트 목표 설정 및 목표 달성을 위한 활동 계획과 예산, 인력, 자원 등의 계획 수립
  3. 실행 executing 그룹 - 핵심 프로세스는 프로젝트 계획 실행으로 계획을 세운대로 실제 수행
  4. 통제 cotrollig 그룹 - 프로젝트 통제: 계획 대비 목표의 진척 상황을 주기적으로 감시하고 성과를 측정
  5. 종료closing 그룹 - 프로젝트 통제: 계획 대비 목표의 진척 상황을 주기적으로 감시하고 성과 측정
