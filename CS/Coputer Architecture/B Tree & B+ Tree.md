**이진 트리**

- 하나의 부모가 두 개의 자식

- ## 검색 효율이 선형검색 급으로 떨어질 수 있다
  
  ```
    ![Untitled](<https://prod-files-secure.s3.us-west-2.amazonaws.com/508e4892-0806-4de8-bdcd-6846439ea664/6119694d-f149-4d30-8248-2c52e7f42a36/Untitled.png>)
  ```

- 하지만 간결함과 균형만 맞다면 검색, 삽입, 삭제 모두 O(logN)의 성능

→ 개선해서 나온 것이 balanced tree

- Balanced Tree
  - AVL Tree
  - Red-Black Tree
  - B-Tree, B+ Tree

# **B- Tree**

---

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/508e4892-0806-4de8-bdcd-6846439ea664/923d215c-29dd-4451-ad27-93212ef1e57b/Untitled.png)

> **탐색 성능을 높이기 위해 균형 있게 높이를 유지하는 Balanced Tree의 일종.**

- 이진 트리를 확장해서, 노드가 더 많은 수의 자식을 가질 수 있게 일반화
- 자식 노드 수에 대한 일반화를 진행하면서, 트리의 균형을 자동으로 조정
- 최대 M개의 자식을 가질 수 있는 B-Tree → **M차 B-Tree**

### **규칙**

- 노드의 자료 수가 N이면, 자식 수는 N+1이어야 함
- 각 노드의 자료는 정렬된 상태여야 함
- 루트 노드는 적어도 2개 이상의 자식을 가져야 함
- 루트 노드를 제외한 모든 노드는 최소 M/2개, 최대 M개의 자료를 가져야 함
- 외부 노드로 가는 경로의 길이는 모두 같음(모든 리프노드가 같은 레벨)
- 입력 자료는 중복 될 수 없음

### **장점**

- 대량의 데이터 처리에 효율적
  - 대량의 데이터는 메모리 보다는 하드디스크 혹은 SSD에 저장되어야 하는데,  이들 외부 기억 장치들은 블럭 단위로 입출력을 하기 때문이다.
  - 예를 들어 한 블럭이 1024 바이트면, 2바이트를 읽으나 1024바이트를 읽으나 똑같은 입출력 비용 발생
  - 하나의 노드를 모두 1024바이트로 꽉 채워서 조절할 수 있으면 입출력에 있어서 효율적인 구성을 갖출 수 있다.
  - 데이터베이스 시스템의 인덱스 저장 방법으로 애용

# **B+ Tree**

---

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/508e4892-0806-4de8-bdcd-6846439ea664/14098dd2-bda7-4b29-8040-49655d8ed110/Untitled.png)

> **B-Tree의 변형 구조로, index 부분과 leaf 노드로 구성된 순차 데이터 부분으로 이루어 짐**

- 모든 key, data가 리프노드에 모여있다.

- 모든 리프노드가 연결리스트의 형태를 띄고 있다.

- 키 중복이 가능

- database 에서의 B+ tree
  
  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/508e4892-0806-4de8-bdcd-6846439ea664/f8555d1a-14e9-45bf-9061-3b8ef8b69b30/Untitled.png)
  
  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/508e4892-0806-4de8-bdcd-6846439ea664/5fd1b439-2a53-4e5e-83f7-a69c11c7b47a/Untitled.png)

### **장점**

- leaf 노드끼리 연결 리스트로 연결되어 있어서 범위 탐색에 매우 유리함
- **leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있다.**
  - **하나의 node에 더 많은 포인터를 가질 수 있기 때문에 트리의 높이가 더 낮아지므로 검색 속도를 높일 수 있다.**
- 범위 탐색시, B+Tree는 leaf node에만 데이터가 저장되어 있고, leaf node끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모된다.

### **단점**

- B-tree의 경우 최상 케이스에서는 루트에서 끝날 수 있지만, B+tree에서 데이터를 비교/검색 하기 위해서는 무조건 leaf 노드까지 내려가야 한다.

### 정리

| 구분     | B- tree           | B+ tree               |
| ------ | ----------------- | --------------------- |
| 데이터 저장 | 모든 노드             | 오직 리프 노드              |
| 접근     | 임의접근, 순차접근        | 임의접근, 순차접근 빠름         |
| 키 중복   | X                 | O (데이터는 리프노드에만 있기 때문) |
| 검색     | 루트 노드와의 거리에 따라 다름 | 리프노드까지 가야 데이터 존재      |
|        |                   |                       |
|        |                   |                       |

**Q. B tree에 대해 말씀해 주세요**

**A.**

데이터베이스, 파일 시스템에서 널리 사용되는 트리 자료구조의 일종으로, 이진 트리를 확장해서 더 많은 수의 자식을 가질 수 있게 일반화 시킨 것이 B-tree이다.

자식 수에 대한 일반화를 진행하면서, 하나의 레벨에 더 저장되는 것 뿐만 아니라 트리의 균형을 자동으로 맞춰주는 로직까지 갖추었다.