## **메인 메모리(main memory)**

---

> 메인 메모리는 CPU가 직접 접근할 수 있는 기억 장치
> 
> 프로세스가 실행되려면 프로그램이 메모리에 올라와야 함

주소가 할당된 일련의 바이트들로 구성되어 있음

CPU는 레지스터가 지시하는대로 메모리에 접근하여 다음에 수행할 명령어를 가져옴

명령어 수행 시 메모리에 필요한 데이터가 없으면 해당 데이터를 우선 가져와야 함

이 역할을 하는 것이 바로 **MMU**.

### **MMU (Memory Management Unit, 메모리 관리 장치)**

---

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/508e4892-0806-4de8-bdcd-6846439ea664/75f0214e-ad27-48be-b3d4-1a6ae4acbe28/Untitled.png)

![img1.daumcdn.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/508e4892-0806-4de8-bdcd-6846439ea664/be2a53fb-53ed-48b4-8103-4bc3add7d504/img1.daumcdn.png)

> 논리적 주소를 물리적 주소로 변환해주는 하드웨어

- *논리적 주소?*
  
  만약 운영체제가 32bit 시스템일 경우, 2의 32승 즉 **4G의 address space**

- 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리해주는 하드웨어

- MMU는 사용자가 기억장소를 일일이 할당해야 하는 불편을 없애준다

- *TLB* (Translation Lookaside Buffer)
  
  가상 메모리 주소를 물리적인 주소로 변환하는 속도를 높이기 위해 사용되는 캐시
  
  최근에 일어난 가상 메모리 주소와 물리 주소의 변환 테이블 저장

---

<aside>
💡 메모리 공간은 한정되어 있다. 어떻게 하면 이 한정된 메모리를 효율적으로 관리할 수 있을까? → **가상 메모리**

</aside>

프로그램이 메모리로 올라올 떄에는 전체 코드가 아닌, 실행될 때 필요한 **국부적인 코드만** 올라온다.

프로그램의 일부만이 메모리로 계속적으로 올라가는 것이므로, 실제적으로 메모리로 올라가는 크기의 총 합 은 결코 메모리를 초과하지 않는다.

또한 MMU는 일일이 모든 물리적 주소를 사용하는 것이 아니라 논리적 주소를 사용하여 실행에 필요한 영역만 그때 그때 읽어오는 방식으로 관리해 줌으로써

프로그래머가 메모리의 제한적인 환경에 신경 쓰지 않을 수 있게 도와 준다.

## 가상 메모리

---

> 메인 메모리를 2차 저장장치(디스크)의 캐시로 사용하는 기술

- 여러 프로그램들이 효과적이고 안전하게 **메인 메모리**를 **공유**할 수 있게 하기 위하여
- 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이다.
  - 실행에 필요한 부분만 메모리에 올려 실행
- CPU는 TLB, MMU 를 사용하여 가상 메모리 주소에 접근한다.
- **Paging** 또는 **Segmentation** 을 사용한다.

### **장점**

- 사용자가 기억장소를 일일히 할당하는 불편을 없애준다.
- 프로세스의 크기가 실제 메모리의 용량을 초과해도 실행될 수가 있다.
- 물리적 메모리의 용량이 충분히 크다하더라도 다중 프로그래밍이 가능하다.

### **단점**

- 가상 메모리로 실행하는 것은 물리 메모리로 실행하는 것보다 느리다.

- 페이징
  
  물리 메모리를 일정한 크기인 **Frame**으로 나누고, 논리 메모리를 Frame과 동일한 크기의 **Page**로 나눈다.
  
  이후 필요한 Page를 Frame에 적재하고 실행한다.
  
  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/508e4892-0806-4de8-bdcd-6846439ea664/3f24c420-6b58-4028-bd07-d8f9b30a408b/Untitled.png)
  
  - 각 Page는 연속적이지 않은 공간에 존재할 수 있다.
  - 각 프로세스는 각자의 Page Table 을 가진다.
  
  ### **장점**
  
  - 가상메모리 사용의 장점을 가진다.
  - 외부단편화가 발생하지 않는다.
    - Frame의 크기와 Page의 크기가 동일하기 때문이다.
  
  ### **단점**
  
  - 내부단편화가 발생한다.
    - 마지막 Frame에서 physical memory가 frame 크기로 나누어 떨어지지 않을 경우

### **메모리 과할당(over allocating)**

> 실제 메모리의 사이즈보다 더 큰 사이즈의 메모리를 프로세스에 할당한 상황

페이지 기법과 같은 메모리 관리 기법은 사용자가 눈치 채지 못하도록 눈속임을 통해 메모리를 할당해줌 (가상 메모리를 이용해서)

과할당 상황에 대해서 사용자를 속인 것을 들킬만한 상황이 존재함

1. 프로세스 실행 도중 페이지 폴트 발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리의 빈 프레임에 페이지를 올려야 하는데, 모든 메모리가 사용중이라 빈 프레임이 없음

이러한 과할당을 해결하기 위해선, 빈 프레임을 확보할 수 있어야 함

1. 메모리에 올라와 있는 한 프로세스를 종료시켜 빈 프레임을 얻음
2. 프로세스 하나를 swap out하고, 이 공간을 빈 프레임으로 활용

swapping 기법을 통해 공간을 바꿔치기하는 2번 방법과는 달리 1번은 사용자에게 페이징 시스템을 들킬 가능성이 매우 높아서 하면 안됨

(페이징 기법은 사용자 모르게 시스템 능률을 높이기 위해 선택한 일이므로 들키지 않게 처리해야한다)

따라서, 2번과 같은 해결책을 통해 페이지 교체가 이루어져야 함

### **페이지 교체**

> 메모리 과할당이 발생했을 때, 프로세스 하나를 swap out해서 빈 프레임을 확보하는 것

1. 프로세스 실행 도중 페이지 부재 발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리에 빈 프레임이 있는지 확인
4. 빈 프레임에 페이지 폴트가 발생한 페이지를 올리고, 페이지 테이블 업데이트

페이지 교체가 이루어지면 아무일이 없던것 처럼 프로세스를 계속 수행시켜주면서 사용자가 알지 못하도록 해야 함

이때, 아무일도 일어나지 않은 것처럼 하려면, 페이지 교체 당시 오버헤드를 최대한 줄여야 함
