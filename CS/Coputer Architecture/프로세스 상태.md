# 

## 프로세스 상태

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A9%E1%84%86%E1%85%B5%E1%86%AB%209ac9921d72d641e6a50f94afb64bbe08/Untitled.png)

---

**프로세스의 상태 전이**

- **디스패치(Dispatch)**
  - `준비 상태 → 실행 상태`
  - 준비 리스트에 있는 여러 프로세스 중 실행될 프로세스를 선정하여 CPU를 할당
- **타이머 런 아웃(Timer Run Out)**
  - `실행 상태 → 준비 상태`
  - 지정된 시간이 초과되면 CPU 반납 후 다시 준비 상태로 전이
- **블록(Block)**
  - `실행 상태 → 대기 상태`
  - 지정된 할당 시간을 초과하기 전 입출력 또는 기타 사건이 발생하면 입출력이 완료될 때까지 대기 상태로 전이
- **웨이크 업(Wake-up)**
  - `대기 상태 → 준비 상태`
  - 어느 순간 입출력이 종료되면 대기 상태의 프로세스에게 입출력 종료 사실을 알려주고 준비 상태로 전이

# **CPU Scheduling**

> CPU 를 잘 사용하기 위해 프로세스를 잘 배정하는 것

- 단일 프로세서 시스템에서는 한 번에 한 프로세스만 실행될 수 있다.

- I/O 작업 등으로 사용자의 작업을 기다리거나 데이터 출력시 CPU는 일을 하지 않는다

- 그렇다면 여러 프로세스를 처리할 때, 한 프로세스가 모든 작업이 끝날때까지 기다렸다가 다음 프로세스를 실행하는 방법보다 **한 프로세스를 실행 가능한 시점까지 실행하고, I/O 등 CPU를 사용하지 않는 작업을 할 때는 다른 프로세스를 실행한다**

- 목표
  
  - 가능하면 많은 일을 수행할 수 있게 (처리량 최대화)
  - 프로세스의 대기 시간을 최소화
  - 기한 (데드라인) 맞추기

## 비선점 스케쥴링 ( Non-Preemptive scheduling)

---

> 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없다.

- 모든 프로세스에 대한 요구를 공정하게 처리
- 어떤 프로세스가 CPU를 할당 받으면 그 프로세스가 종료되거나 IO request가 발생하여 자발적으로 대기 상태로 들어갈 때까지 계속 실행된다
- scheduler 호출 빈도가 낮고 context switching overhead가 적다
- 작업 종료 후 CPU 반환 시까지 다른 프로세스가 CPU를 점유할 수 없는 스케줄링 방식

**FCFS (First Come First Served)**

- **큐**에 도착한 순서대로 CPU 할당
- 실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐

**SJF (Shortest Job First)**

- 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
- FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리
- 대기시간이 긴 프로세스는 무한정 기다리게되는 **기아 상태**에 빠질 수 있다

**우선순위 스케줄링(Priority Scheduling)**

- **우선순위**를 계산하여 점유 불평등을 보완한 방법(SJF의 단점 보완)

- 각 프로세스의 우선순위가 정해지면, 우선순위가 제일 높은 프로세스에게 CPU를 할당하되, 우선순위가 같은 경우에는 **FCFS 방식**을 적용한다.

- 기아 상태 가능
  
  - 우선순위가 높은 작업이 계속적으로 들어올 경우 우선순위가 낮은 작업은 준비상태에서 보장 없이 머물게 된다
  - 이러한 문제는 시스템에 머무는 시간이 증가할수록 우선순위를 높여주는 에이징(Aging)으로 해결한다.

## 선점 스케쥴링 ( Preemptive scheduling)

---

> 하나의 프로세스가 다른 프로세스 대신에 프로세서를 차지 할 수 있다

- 하나의 프로세스가 CPU를 차지 중에, 우선 순위가 높은 다른 프로세스가 현재 프로세스를 중단 시키고 CPU를 대신 점유
- 실행 중 time-out , i/o 발생, event 대기 중 다른 프로세스에 양보
- 현대 OS는 대부분 시분할 선점형 스케줄링을 사용
- scheduler 호출 빈도가 높고 context switching overhead가 크다

**SRT(Shortest Remaining Time First)**

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A9%E1%84%86%E1%85%B5%E1%86%AB%209ac9921d72d641e6a50f94afb64bbe08/Untitled%201.png)

- SRT(Shortest Remaining Time First)
- 남은 처리 시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 선점됨
- 선점형 SJF 스케줄링 → 기아 상태 빠질 수 있음

**Round Robin**

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A9%E1%84%86%E1%85%B5%E1%86%AB%209ac9921d72d641e6a50f94afb64bbe08/Untitled%202.png)

- FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 `Time Quantum` 만큼 CPU를 할당 받음
  - `Time Quantum` or `Time Slice` : 실행의 최소 단위 시간
- 할당 시간(`Time Quantum`)이 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching) 잦아져서 오버헤드 증가

**Multilevel-Queue (다단계 큐)**

-   ![https://user-images.githubusercontent.com/13609011/91695428-16a2f480-eba9-11ea-8d91-17d22bab01e5.png](https://user-images.githubusercontent.com/13609011/91695428-16a2f480-eba9-11ea-8d91-17d22bab01e5.png)
  
  - 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 기법
  - 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 `Time Quantum`을 설정 해주는 방식 사용
  - 우선순위가 높은 큐는 작은 `Time Quantum` 할당. 우선순위가 낮은 큐는 큰  할당.

**Multilevel-Feedback-Queue (다단계 피드백 큐)**

-   ![https://user-images.githubusercontent.com/13609011/91695489-2cb0b500-eba9-11ea-8578-6602fee742ed.png](https://user-images.githubusercontent.com/13609011/91695489-2cb0b500-eba9-11ea-8578-6602fee742ed.png)
  
  - 다단계 큐에서 자신의 `Time Quantum`을 다 채운 프로세스는 밑으로 내려가고 자신의 을 다 채우지 못한 프로세스는 원래 큐 그대로
    - Time Quantum을 다 채운 프로세스는 CPU burst 프로세스로 판단하기 때문
  - 짧은 작업에 유리, 입출력 위주(Interrupt가 잦은) 작업에 우선권을 줌
  - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여줌

### **CPU 스케줄링 척도**

---

CPU 사용률(Utilization)

- 전체 시스템 시간 중에서 **CPU가 작업을 처리하는 시간의 비율**
- 유휴 시간이 적을수록 CPU 사용률이 높다

처리량(Throughput)

- CPU가 **단위 시간당 작업을 마친 프로세스의 수**
- CPU 사용률이 높고 프로세스들에 적정한 시간을 공평하게 제공했다면 처리량이 높다

응답 시간(Response Time)

- 대화식 시스템에서 요청 후 응답이 오기 시작할 때까지의 시간

대기 시간(Waiting Time)

- 프로세스가 준비 큐에서 대기하는 시간들의 총 합

반환 시간(Turnaround Time) 

- 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때 까지 걸린 시간

## 면접 질문

---

- 스케줄링에 대해 설명해주세요.
  
    여러 프로세스가 있고, 이 프로세스들이 자원(CPU 등)을 동시에 요구하는데 자원은 제한되어 있습니다.  그럴 때 제한된 자원들을 어떻게 나눠줄 것 인지에 대한 정책을 말합니다.

- CPU 스케줄링의 종류를 설명해주세요.

- 선점 스케줄링과 비선점 스케줄링의 차이점에 대해 설명해주세요.
  
    **선점** : CPU를 할당받아 실행 중인 프로세스로부터 CPU를 선점(빼앗는 것)하여 다른 프로세스를 할당 할 수 있는 방식
  
    Ex) RR, SRT, MLQ, MFQ
  
    **비선점** : CPU를 할당받은 프로세스가 스스로 CPU를 반납할 때까지 CPU를 독점하여 사용 방식
  
    Ex) FCFS, SJR, HRN