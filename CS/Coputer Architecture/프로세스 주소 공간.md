# 

### 프로세스 주소 공간

: 프로세스가 메모리를 할당 받으면, 자신만의 방법으로 메모리를 관리하기 위해 이 공간들을 어떤 구조로 관리하는데, 우리는 이를 **프로세스 주소 공간**이라고 부른다.

(프로그램이 CPU에 의해 실행됨 → 프로세스가 생성되고 메모리에 **프로세스 주소 공간**이 할당됨)

![Untitled](%E1%84%80%E1%85%B5%E1%86%B7%E1%84%89%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AE%E1%86%AB%2015565c09e22649de8049ab3575088f58/Untitled.png)

프로세스의 주소 공간은 대략적으로 다음과 같이 생겼으며, 각각의 구역을 살펴보면 다음과 같다.

- **Stack 영역  (함수, 지역 변수 저장)**
  
  - 함수의 호출과 관계되는 *지역 변수와 매개변수*가 저장되는 영역이다.
    
       → **LIFO(가장 나중에 들어간게 먼저 나옴)특성**
  
  - Stack 영역의 값은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.
  
  - 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
  
  - 재귀 함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 stack overflow 에러가 발생한다.

- **Heap 영역**:
  
  - **런타임에 크기가 결정되는** 영역이다.
  - 사용자에 의해 공간이 동적으로 할당 및 해제된다.
  - 주로 참조형 데이터 (ex. 클래스) 등의 데이터가 할당된다.
  - 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

- **Data 영역  (전역 변수 저장)**
  
  - 전역 변수나 Static 변수 등 프로그램이 사용할 수 있는 데이터를 저장하는 영역이다.
  
  - 어떤 프로그램에 전역/static 변수를 참조하는 코드가 존재한다면, 이 프로그램은 컴파일 된 후에 data 영역을 참조하게 된다.
  
  - 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
  
  - 단, *초기화 되지 않은* 변수가 존재한다면, 이는 BSS 영역에 저장된다.
    
    * BBS: 전역 변수와 static 변수를 저장하는 데 사용되는 메모리 세그먼트 중 하나. 
    
    BSS 세그먼트는 프로그램이 실행될 때 자동으로 0으로 초기화됩니다. 이 세그먼트는 프로그램이 시작될 때 할당되며, 프로그램이 종료될 때 메모리에서 해제)

- **Text (Code) 영역  (프로그램 소스 코드 저장)**
  
  - 프로그램이 실행될 수 있도록 CPU가 해석 가능한 기계어 코드가 저장되어 있는 공간으로, 프로그램이 수정되면 안 되므로 ReadOnly 상태로 저장 되어있다.

***왜 이렇게 구역을 나눈건가요?***

최대한 데이터를 공유하여 메모리 사용량을 줄여야 한다.

Code는 같은 프로그램 자체에서는 모두 같은 내용이기 때문에 따로 관리하여 공유한다.

Stack과 data를 나눈 이유는, 스택 구조의 특성과 전역 변수의 활용성을 위한 것이다.

- **Data 영역과 Stack 영역**
  
    Code 영역은 기계어 코드가 들어있으니 다른 구역과 너무 다르고, Heap 영역은 런타임에 크기가 결정되는 영역이다.
  
    그렇다면 Stack 영역과 Data 영역을 구분한 이유는 무엇일까? 가장 큰 이유는 **역할의 분배**이다. 우리는 Stack 영역을 통해 함수의 흐름을 관리하고, Data 영역 (+BSS 영역)을 통해 전역 변수, static 변수를 관리한다.
  
    만약 한 프로세스가 여러개의 스레드를 갖는다면, 각각의 스레드는 자신만의 Stack 영역을 갖는다. 이는 스레드 내에서 수행되는 함수의 흐름을 각각 관리하기 위함이다.
  
    여기에서 영역을 구분한 또 다른 중요한 이유가 나오는데, 바로 **Data 영역의 공유**이다. 각각의 스레드는 Stack 영역을 갖긴 하지만 Data 영역은 공유한다. 즉, 각각의 스레드가 사용하기 위해 Data 영역의 동일한 내용을 공유함으로써, 똑같은 공간을 여러개 만들지 않고 메모리를 절약할 수 있다.
  
    ![Untitled](%E1%84%80%E1%85%B5%E1%86%B7%E1%84%89%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AE%E1%86%AB%2015565c09e22649de8049ab3575088f58/Untitled%201.png)
  
    ,실제로 각 스레드가 갖고 있는 것은 Stack 영역 밖에 없음
  
    즉, 나머지 공간은 프로세스의 값을 함께 쓰고 있고, 즉 다른 스레드와 공유한다고 볼 수 있다.
  
    이 때문에, Data 영역에 있는 자원은 동시에 여러 스레드가 접근할 수 있고, 여기서 발생하는 문제를 해결하는 방법이 `동기화`
  
    **프로그램의 함수와 지역 변수는, LIFO(가장 나중에 들어간게 먼저 나옴)특성을 가진 스택에서 실행된다.**
  
    **따라서 이 함수들 안에서 공통으로 사용하는 '전역 변수'는 따로 지정해주면 메모리를 아낄 수 있다.**

- **Heap의 크기와 Stack 크기**
  
    우리가 자바 코드를 작성하고, 이 코드를 실행할 때, 다음과 같은 명령어를 쳐 본 경험이 있을 것이다.
  
  ```
  java -Xmx4096m test
  ```
  
    이 명령어는 *test* 라는 이름을 갖는 프로그램을 JVM 상에서 실행하되, 최대 힙 크기를 4096M (= 4G) 할당하라는 의미이다.
  
    추가로, UNIX 계열 운영체제의 경우 다음과 같은 명령어를 통해 Stack 영역의 최대 크기를 확인할 수 있다.
  
  ```
  ulimit -s
  ```
  
    이 명령어를 이용하면 Stack 영역의 최대 크기를 수정할 수도 있지만, 현재 최대 크기도 확인할 수 있는데, 딱 8MB라고 나올 것이다.
  
    어? Stack 영역과 Heap 영역은 같은 공간을 공유하는게 아니었나? 왜 필요한 크기가 다를까?
  
    ![Untitled](%E1%84%80%E1%85%B5%E1%86%B7%E1%84%89%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AE%E1%86%AB%2015565c09e22649de8049ab3575088f58/Untitled%202.png)
  
    위 그림은 Java에서의 Stack 영역과 Heap 영역을 나타낸다. 잘 살펴보면, Stack 영역에 등장하는 각각의 변수들은 Heap 영역에 위치한 실제 Object의 참조를 갖고 있는 것을 볼 수 있다. 즉, 실제 객체는 Heap 영역에서 관리되기 때문에 Stack 영역의 크기는 생각보다 클 필요가 없다는 것을 알 수 있다.
  
    클 필요가 없다는 것은 알았는데, 그렇다면 정말 두 영역은 서로 같은 공간을 공유하는게 아닌건가?
  
    사실, Stack 영역은 생성과 동시에 크기가 정해진다. 즉, 크기가 한 번 정해지면 바뀌지 않기 때문에, Heap 영역과 상관 없이 크기의 제한을 갖는다. 즉, 우리가 자주 볼 수 있는 Stack Overflow 같은 문제는, 힙 영역을 침범해서가 아니라 정해진 Stack 영역의 크기를 초과해서 발생한 문제라고 볼 수 있다.