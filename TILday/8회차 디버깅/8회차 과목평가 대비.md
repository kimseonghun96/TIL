```python
# RuntimeError at/catch
# no active exception to raise
# render 안적으면 틀림

def cathc(request):
    message = request.GET.get('message')
    context {
        'message' : message,

    }
    return render(request. 'catch.html', request)
```

```python
# include되는 앱의 urls.py에 urlpattenrs가 작성되어 있지 않다면 에러가 발생한다.
# 예를들어, pages 앱의 urlpatters가 빈리스트라도 작성되어 있어야한다.
from django.urls import path
from . import views

urlpatters = {

    }
```

```python
# app_name을 지정한 이후에는 url태그에서 반드시 app_name : url_name 형태로만 사용해야한다.
# 그렇지 않으면 NoReverceMatch에러가 발생한다.
```

```python
# CSRF 공격 방어
# 사용자의 데이터에 임의의 난수 값(token)을 부여해 매요청마다 해당 난수 값을 포함시켜 전송
# 시키도록 한다.

html.method = 'POST'면 적어야한다
{% crsf_token %}

# 해당 태그가 없다면 40 forbidden으로 응답한다.
```

```python
# django.views.decoratiors.http의 데코레이터를 사용하며
# 요청 매서드를 기반으로 접근을 제한 할 수 있음
# 일치하지 않는 메서드 요청이라면 405 Method Not Allowed를 반환
# 405는 요청 방법이 서버에게 전달되었거나 사용 불가능한 상태
```

```python
# 외래키 누락 
IntegegrityError at/articles/create/
NOT NULL constraint failed : articles_article.user_id 에러 발생
-> NOT NULL 제약 조건이 실패했다. articles_article xpdlqmfdml user_id 칼럼에게
    게시글 작성 시에 외래키에 저장되어야 할 작성자 정보가 누락되었기 때문
-> 게시글 작성 시 작성자 정보가 함께 저장될 수 있도록 save의 commit 옵션을 이요한다.

def create(request):
    if request.method = 'POST':
        form : Article.Form(request.POST)
        if form.is_valid():
            article  : form.save(commit = False)
            article.user = request.user
            aritcle.save()
            return redirect('articles :  detail', article.pk)
```

```python
1. 로그인 안한 사용자는 사용할 수 없는 로그인이 필요한 기능 사용자 인증 관련에 대해 알아보자!
-> 회원가입을 했는데 오류가 발생하는 경우, 회원가입에 사용하는 UserCreationForm이 우리가 
대체한 커스텀유저모델이 아닌 기존 유저 모델로 인해 작성된 클래스이기 때문이다.

2. 마이그레이션이 안되는 경우
 -> 앱등록을 안해서(반드시 앱을 생성 후 등록해야한다. ISTALLED_APP에 먼저 작성하고
        생성하려면 생성되지 않는다.

3. 유저.모델 장고에서 기본으로 주는  모형, 회원 가입, 커스텀 모델 사용해서 내장 유저 모델 대신 
커스텀 모델을 사용하는 경우
 -> 기본 user Model을 사용하게 될 경우 내장되어 있는 것이 광범위하기 때문에 원하는 속성만 사용
하기 위해 costom_user_model로 설정한다.
```

```python
related_name을 사용하는 경우
트러블 슈팅
ex) User을 기준으로 할지, Like를 기준으로 해야할지 명확하지 않다는 것이 문제

-> 하나의 모델에서 참조하고 있는 유저모델이 두 개가 있음
  1, ERD의 설계 상으로는 문제가 없었으나 물리적으로 모델을 생성할 때 각 필드가 참고하고
        있는 모델이 동일하기 때문에 발생한 문제
    2, 모델을 생성할 때 발생한 문제로, 이는 하나의 모델이 역참조할 때 바라봐야 할 필요가
        무엇인지 확실하게 정의해줘야한다.

-> realted_name 메서드로 충돌피하기
        ManyToMany 필드에 related_name을 지정해주는 것으로 충돌을 피할 수 있다.
  ex)
class Comment(models.Model):
    article = modles.ForeignKey(Article, on_delete=models.CASCADE, related_name = 'commdts')
```

```python
Custom User Model
- Django에서는 bulit_in user model을 제공한다.
- 하지만 프로젝트에 따라 custom User model이 필요한 경우가 많다.
  ex) 회원가입 시 username 대신 e-mail을 식별값으로 사용할 경우
- 따라서 현재 프로젝트에서 사용할 user model을 재정의 해야 한다.
- 모델 관계에 영향을 미치기 때문에 프로젝트 처음에 진행하는 것을 권장
* 프로젝트 중간 일 경우, 데이터베이스 초기화 하는 과정(migrate 오류시 해결방법)
1. migrations 파일 삭제(번호가 붙은 파일만)
2. db.sqlite 삭제
3. python manage.py makemigrations
4. python manage.py migrate
```

```python
Http status code의 의미
1. 200 - 요청이 성공적으로 되었습니다.

2. 400 - 이 응답은 잘못된 문법으로 인하여 서버가 요청을 이해 할 수 없음을 의미합니다.

3. 401 - 비록 HTTP 표준에서는 '미승인'을 명확히 하고 있지만 의미상 응답은 '미인증'을
의미합니다. 클라이언트는 요청한 응답을 받기 위해서는 반드시 스스로를 인증해야 합니다.

4. 403 - 클라이언트는 콘텐츠에 접근할 권리를 가지고 있지 않습니다. 예를들어 그들은 미승인
이어서 서버는 거절을 위한 적절한 응답을 보냅니다. 401과 다른 점은 서버가 클라이언트가 누구
인지 알고 있습니다.

5. 404 - 서버는 요청받은 리소스를 찾을 수 없습니다. 브라우저에서는 알려지지 않는 URL을 의미
합니다

6. 405 Method Not Allowed
- 요청 방법이 서버에 전달 되었으나 사용 불가능한 상태.

7. 500 - 서버는 처리 방법을 모르는 상황이 발생했습니다. 서버는 아직 처리방법을 알 수 없습니다.
```
